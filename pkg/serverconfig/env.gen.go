// Code generated by configgen. DO NOT EDIT.

package serverconfig

import (
	"log/slog"
	"os"
	"strconv"
	"strings"
)

// applyEnvironmentVariables applies environment variables to the configuration
func applyEnvironmentVariables(cfg *Config, log *slog.Logger) error {

	// Apply MIREN_CLICKHOUSE_ADDRESS
	if val := os.Getenv("MIREN_CLICKHOUSE_ADDRESS"); val != "" {

		cfg.Clickhouse.Address = &val
		log.Debug("applied env var", "key", "MIREN_CLICKHOUSE_ADDRESS")

	}

	// Apply MIREN_CLICKHOUSE_HTTP_PORT
	if val := os.Getenv("MIREN_CLICKHOUSE_HTTP_PORT"); val != "" {

		if i, err := strconv.Atoi(val); err == nil {
			cfg.Clickhouse.HttpPort = &i
			log.Debug("applied env var", "key", "MIREN_CLICKHOUSE_HTTP_PORT")
		} else {
			log.Warn("invalid MIREN_CLICKHOUSE_HTTP_PORT value", "value", val, "error", err)
		}

	}

	// Apply MIREN_CLICKHOUSE_INTERSERVER_PORT
	if val := os.Getenv("MIREN_CLICKHOUSE_INTERSERVER_PORT"); val != "" {

		if i, err := strconv.Atoi(val); err == nil {
			cfg.Clickhouse.InterserverPort = &i
			log.Debug("applied env var", "key", "MIREN_CLICKHOUSE_INTERSERVER_PORT")
		} else {
			log.Warn("invalid MIREN_CLICKHOUSE_INTERSERVER_PORT value", "value", val, "error", err)
		}

	}

	// Apply MIREN_CLICKHOUSE_NATIVE_PORT
	if val := os.Getenv("MIREN_CLICKHOUSE_NATIVE_PORT"); val != "" {

		if i, err := strconv.Atoi(val); err == nil {
			cfg.Clickhouse.NativePort = &i
			log.Debug("applied env var", "key", "MIREN_CLICKHOUSE_NATIVE_PORT")
		} else {
			log.Warn("invalid MIREN_CLICKHOUSE_NATIVE_PORT value", "value", val, "error", err)
		}

	}

	// Apply MIREN_CLICKHOUSE_START_EMBEDDED
	if val := os.Getenv("MIREN_CLICKHOUSE_START_EMBEDDED"); val != "" {

		if b, err := strconv.ParseBool(val); err == nil {
			cfg.Clickhouse.StartEmbedded = &b
			log.Debug("applied env var", "key", "MIREN_CLICKHOUSE_START_EMBEDDED")
		} else {
			log.Warn("invalid MIREN_CLICKHOUSE_START_EMBEDDED value", "value", val, "error", err)
		}

	}

	// Apply MIREN_MODE
	if val := os.Getenv("MIREN_MODE"); val != "" {

		cfg.Mode = &val
		log.Debug("applied env var", "key", "MIREN_MODE")

	}

	// Apply MIREN_CONTAINERD_BINARY_PATH
	if val := os.Getenv("MIREN_CONTAINERD_BINARY_PATH"); val != "" {

		cfg.Containerd.BinaryPath = &val
		log.Debug("applied env var", "key", "MIREN_CONTAINERD_BINARY_PATH")

	}

	// Apply MIREN_CONTAINERD_SOCKET_PATH
	if val := os.Getenv("MIREN_CONTAINERD_SOCKET_PATH"); val != "" {

		cfg.Containerd.SocketPath = &val
		log.Debug("applied env var", "key", "MIREN_CONTAINERD_SOCKET_PATH")

	}

	// Apply MIREN_CONTAINERD_START_EMBEDDED
	if val := os.Getenv("MIREN_CONTAINERD_START_EMBEDDED"); val != "" {

		if b, err := strconv.ParseBool(val); err == nil {
			cfg.Containerd.StartEmbedded = &b
			log.Debug("applied env var", "key", "MIREN_CONTAINERD_START_EMBEDDED")
		} else {
			log.Warn("invalid MIREN_CONTAINERD_START_EMBEDDED value", "value", val, "error", err)
		}

	}

	// Apply MIREN_ETCD_CLIENT_PORT
	if val := os.Getenv("MIREN_ETCD_CLIENT_PORT"); val != "" {

		if i, err := strconv.Atoi(val); err == nil {
			cfg.Etcd.ClientPort = &i
			log.Debug("applied env var", "key", "MIREN_ETCD_CLIENT_PORT")
		} else {
			log.Warn("invalid MIREN_ETCD_CLIENT_PORT value", "value", val, "error", err)
		}

	}

	// Apply MIREN_ETCD_ENDPOINTS
	if val := os.Getenv("MIREN_ETCD_ENDPOINTS"); val != "" {

		// Split and clean CSV list
		parts := strings.Split(val, ",")
		cleaned := make([]string, 0, len(parts))
		seen := make(map[string]struct{})
		for _, p := range parts {
			p = strings.TrimSpace(p)
			if p == "" {
				continue
			}
			if _, exists := seen[p]; exists {
				continue
			}
			seen[p] = struct{}{}
			cleaned = append(cleaned, p)
		}
		cfg.Etcd.Endpoints = cleaned
		log.Debug("applied env var", "key", "MIREN_ETCD_ENDPOINTS", "count", len(cleaned))

	}

	// Apply MIREN_ETCD_HTTP_CLIENT_PORT
	if val := os.Getenv("MIREN_ETCD_HTTP_CLIENT_PORT"); val != "" {

		if i, err := strconv.Atoi(val); err == nil {
			cfg.Etcd.HttpClientPort = &i
			log.Debug("applied env var", "key", "MIREN_ETCD_HTTP_CLIENT_PORT")
		} else {
			log.Warn("invalid MIREN_ETCD_HTTP_CLIENT_PORT value", "value", val, "error", err)
		}

	}

	// Apply MIREN_ETCD_PEER_PORT
	if val := os.Getenv("MIREN_ETCD_PEER_PORT"); val != "" {

		if i, err := strconv.Atoi(val); err == nil {
			cfg.Etcd.PeerPort = &i
			log.Debug("applied env var", "key", "MIREN_ETCD_PEER_PORT")
		} else {
			log.Warn("invalid MIREN_ETCD_PEER_PORT value", "value", val, "error", err)
		}

	}

	// Apply MIREN_ETCD_PREFIX
	if val := os.Getenv("MIREN_ETCD_PREFIX"); val != "" {

		cfg.Etcd.Prefix = &val
		log.Debug("applied env var", "key", "MIREN_ETCD_PREFIX")

	}

	// Apply MIREN_ETCD_START_EMBEDDED
	if val := os.Getenv("MIREN_ETCD_START_EMBEDDED"); val != "" {

		if b, err := strconv.ParseBool(val); err == nil {
			cfg.Etcd.StartEmbedded = &b
			log.Debug("applied env var", "key", "MIREN_ETCD_START_EMBEDDED")
		} else {
			log.Warn("invalid MIREN_ETCD_START_EMBEDDED value", "value", val, "error", err)
		}

	}

	// Apply MIREN_SERVER_ADDRESS
	if val := os.Getenv("MIREN_SERVER_ADDRESS"); val != "" {

		cfg.Server.Address = &val
		log.Debug("applied env var", "key", "MIREN_SERVER_ADDRESS")

	}

	// Apply MIREN_SERVER_CONFIG_CLUSTER_NAME
	if val := os.Getenv("MIREN_SERVER_CONFIG_CLUSTER_NAME"); val != "" {

		cfg.Server.ConfigClusterName = &val
		log.Debug("applied env var", "key", "MIREN_SERVER_CONFIG_CLUSTER_NAME")

	}

	// Apply MIREN_SERVER_DATA_PATH
	if val := os.Getenv("MIREN_SERVER_DATA_PATH"); val != "" {

		cfg.Server.DataPath = &val
		log.Debug("applied env var", "key", "MIREN_SERVER_DATA_PATH")

	}

	// Apply MIREN_SERVER_HTTP_REQUEST_TIMEOUT
	if val := os.Getenv("MIREN_SERVER_HTTP_REQUEST_TIMEOUT"); val != "" {

		if i, err := strconv.Atoi(val); err == nil {
			cfg.Server.HttpRequestTimeout = &i
			log.Debug("applied env var", "key", "MIREN_SERVER_HTTP_REQUEST_TIMEOUT")
		} else {
			log.Warn("invalid MIREN_SERVER_HTTP_REQUEST_TIMEOUT value", "value", val, "error", err)
		}

	}

	// Apply MIREN_SERVER_RELEASE_PATH
	if val := os.Getenv("MIREN_SERVER_RELEASE_PATH"); val != "" {

		cfg.Server.ReleasePath = &val
		log.Debug("applied env var", "key", "MIREN_SERVER_RELEASE_PATH")

	}

	// Apply MIREN_SERVER_RUNNER_ADDRESS
	if val := os.Getenv("MIREN_SERVER_RUNNER_ADDRESS"); val != "" {

		cfg.Server.RunnerAddress = &val
		log.Debug("applied env var", "key", "MIREN_SERVER_RUNNER_ADDRESS")

	}

	// Apply MIREN_SERVER_RUNNER_ID
	if val := os.Getenv("MIREN_SERVER_RUNNER_ID"); val != "" {

		cfg.Server.RunnerId = &val
		log.Debug("applied env var", "key", "MIREN_SERVER_RUNNER_ID")

	}

	// Apply MIREN_SERVER_SKIP_CLIENT_CONFIG
	if val := os.Getenv("MIREN_SERVER_SKIP_CLIENT_CONFIG"); val != "" {

		if b, err := strconv.ParseBool(val); err == nil {
			cfg.Server.SkipClientConfig = &b
			log.Debug("applied env var", "key", "MIREN_SERVER_SKIP_CLIENT_CONFIG")
		} else {
			log.Warn("invalid MIREN_SERVER_SKIP_CLIENT_CONFIG value", "value", val, "error", err)
		}

	}

	// Apply MIREN_TLS_ADDITIONAL_IPS
	if val := os.Getenv("MIREN_TLS_ADDITIONAL_IPS"); val != "" {

		// Split and clean CSV list
		parts := strings.Split(val, ",")
		cleaned := make([]string, 0, len(parts))
		seen := make(map[string]struct{})
		for _, p := range parts {
			p = strings.TrimSpace(p)
			if p == "" {
				continue
			}
			if _, exists := seen[p]; exists {
				continue
			}
			seen[p] = struct{}{}
			cleaned = append(cleaned, p)
		}
		cfg.Tls.AdditionalIps = cleaned
		log.Debug("applied env var", "key", "MIREN_TLS_ADDITIONAL_IPS", "count", len(cleaned))

	}

	// Apply MIREN_TLS_ADDITIONAL_NAMES
	if val := os.Getenv("MIREN_TLS_ADDITIONAL_NAMES"); val != "" {

		// Split and clean CSV list
		parts := strings.Split(val, ",")
		cleaned := make([]string, 0, len(parts))
		seen := make(map[string]struct{})
		for _, p := range parts {
			p = strings.TrimSpace(p)
			if p == "" {
				continue
			}
			if _, exists := seen[p]; exists {
				continue
			}
			seen[p] = struct{}{}
			cleaned = append(cleaned, p)
		}
		cfg.Tls.AdditionalNames = cleaned
		log.Debug("applied env var", "key", "MIREN_TLS_ADDITIONAL_NAMES", "count", len(cleaned))

	}

	// Apply MIREN_TLS_STANDARD_TLS
	if val := os.Getenv("MIREN_TLS_STANDARD_TLS"); val != "" {

		if b, err := strconv.ParseBool(val); err == nil {
			cfg.Tls.StandardTls = &b
			log.Debug("applied env var", "key", "MIREN_TLS_STANDARD_TLS")
		} else {
			log.Warn("invalid MIREN_TLS_STANDARD_TLS value", "value", val, "error", err)
		}

	}

	return nil
}
