// Code generated by configgen. DO NOT EDIT.

package serverconfig

import (
	"fmt"
	"net"
)

// Validate validates the configuration
func (c *Config) Validate() error {

	if err := c.Clickhouse.Validate(); err != nil {
		return fmt.Errorf("clickhouse: %w", err)
	}

	if err := c.Containerd.Validate(); err != nil {
		return fmt.Errorf("containerd: %w", err)
	}

	if err := c.Etcd.Validate(); err != nil {
		return fmt.Errorf("etcd: %w", err)
	}
	// Validate mode
	if c.Mode != nil {
		validModes := map[string]bool{
			"standalone":  true,
			"distributed": true,
		}
		if !validModes[*c.Mode] {
			return fmt.Errorf("invalid mode %q: must be one of [standalone distributed]", *c.Mode)
		}
	}

	if err := c.Server.Validate(); err != nil {
		return fmt.Errorf("server: %w", err)
	}

	if err := c.Tls.Validate(); err != nil {
		return fmt.Errorf("tls: %w", err)
	}
	return nil
}

// Validate validates ClickHouseConfig
func (c *ClickHouseConfig) Validate() error {

	// Validate http_port
	if c.HttpPort != nil && (*c.HttpPort < 1 || *c.HttpPort > 65535) {
		return fmt.Errorf("http_port must be between 1 and 65535, got %d", *c.HttpPort)
	}

	// Validate interserver_port
	if c.InterserverPort != nil && (*c.InterserverPort < 1 || *c.InterserverPort > 65535) {
		return fmt.Errorf("interserver_port must be between 1 and 65535, got %d", *c.InterserverPort)
	}

	// Validate native_port
	if c.NativePort != nil && (*c.NativePort < 1 || *c.NativePort > 65535) {
		return fmt.Errorf("native_port must be between 1 and 65535, got %d", *c.NativePort)
	}

	// Check for port conflicts in ClickHouseConfig
	seen := make(map[int]bool)
	if c.HttpPort != nil {
		if seen[*c.HttpPort] {
			return fmt.Errorf("port conflict: port %d is used multiple times", *c.HttpPort)
		}
		seen[*c.HttpPort] = true
	}
	if c.InterserverPort != nil {
		if seen[*c.InterserverPort] {
			return fmt.Errorf("port conflict: port %d is used multiple times", *c.InterserverPort)
		}
		seen[*c.InterserverPort] = true
	}
	if c.NativePort != nil {
		if seen[*c.NativePort] {
			return fmt.Errorf("port conflict: port %d is used multiple times", *c.NativePort)
		}
		seen[*c.NativePort] = true
	}

	return nil
}

// Validate validates ContainerdConfig
func (c *ContainerdConfig) Validate() error {

	// Check for port conflicts in ContainerdConfig

	return nil
}

// Validate validates EtcdConfig
func (c *EtcdConfig) Validate() error {

	// Validate client_port
	if c.ClientPort != nil && (*c.ClientPort < 1 || *c.ClientPort > 65535) {
		return fmt.Errorf("client_port must be between 1 and 65535, got %d", *c.ClientPort)
	}

	// Validate http_client_port
	if c.HttpClientPort != nil && (*c.HttpClientPort < 1 || *c.HttpClientPort > 65535) {
		return fmt.Errorf("http_client_port must be between 1 and 65535, got %d", *c.HttpClientPort)
	}

	// Validate peer_port
	if c.PeerPort != nil && (*c.PeerPort < 1 || *c.PeerPort > 65535) {
		return fmt.Errorf("peer_port must be between 1 and 65535, got %d", *c.PeerPort)
	}

	// Check for port conflicts in EtcdConfig
	seen := make(map[int]bool)
	if c.ClientPort != nil {
		if seen[*c.ClientPort] {
			return fmt.Errorf("port conflict: port %d is used multiple times", *c.ClientPort)
		}
		seen[*c.ClientPort] = true
	}
	if c.HttpClientPort != nil {
		if seen[*c.HttpClientPort] {
			return fmt.Errorf("port conflict: port %d is used multiple times", *c.HttpClientPort)
		}
		seen[*c.HttpClientPort] = true
	}
	if c.PeerPort != nil {
		if seen[*c.PeerPort] {
			return fmt.Errorf("port conflict: port %d is used multiple times", *c.PeerPort)
		}
		seen[*c.PeerPort] = true
	}

	// Validate etcd endpoints requirement
	if c.StartEmbedded != nil && !*c.StartEmbedded && len(c.Endpoints) == 0 {
		return fmt.Errorf("etcd endpoints must be set when start_embedded=false")
	}

	return nil
}

// Validate validates ServerConfig
func (c *ServerConfig) Validate() error {

	// Validate address
	if c.Address != nil && *c.Address != "" {
		if _, _, err := net.SplitHostPort(*c.Address); err != nil {
			return fmt.Errorf("invalid address %q: %w", *c.Address, err)
		}
	}

	// Validate http_request_timeout minimum
	if c.HttpRequestTimeout != nil && *c.HttpRequestTimeout < 1 {
		return fmt.Errorf("http_request_timeout must be at least 1, got %d", *c.HttpRequestTimeout)
	}

	// Validate runner_address
	if c.RunnerAddress != nil && *c.RunnerAddress != "" {
		if _, _, err := net.SplitHostPort(*c.RunnerAddress); err != nil {
			return fmt.Errorf("invalid runner_address %q: %w", *c.RunnerAddress, err)
		}
	}

	// Check for port conflicts in ServerConfig

	return nil
}

// Validate validates TLSConfig
func (c *TLSConfig) Validate() error {

	// Validate additional_ips
	for _, ip := range c.AdditionalIps {
		if net.ParseIP(ip) == nil {
			return fmt.Errorf("invalid IP address %q in additional_ips", ip)
		}
	}

	// Check for port conflicts in TLSConfig

	return nil
}
