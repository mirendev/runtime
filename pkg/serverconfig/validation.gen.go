// Code generated by configgen. DO NOT EDIT.

package serverconfig

import (
	"fmt"
	"net"
	"regexp"
)

// Validate validates the configuration
func (c *Config) Validate() error {

	if err := c.Buildkit.Validate(); err != nil {
		return fmt.Errorf("buildkit: %w", err)
	}

	if err := c.Containerd.Validate(); err != nil {
		return fmt.Errorf("containerd: %w", err)
	}

	if err := c.Etcd.Validate(); err != nil {
		return fmt.Errorf("etcd: %w", err)
	}
	// Validate mode
	if c.Mode != nil {
		validModes := map[string]bool{
			"standalone":  true,
			"distributed": true,
		}
		if !validModes[*c.Mode] {
			return fmt.Errorf("invalid mode %q: must be one of [standalone distributed]", *c.Mode)
		}
	}

	if err := c.Server.Validate(); err != nil {
		return fmt.Errorf("server: %w", err)
	}

	if err := c.TLS.Validate(); err != nil {
		return fmt.Errorf("tls: %w", err)
	}

	if err := c.Victorialogs.Validate(); err != nil {
		return fmt.Errorf("victorialogs: %w", err)
	}

	if err := c.Victoriametrics.Validate(); err != nil {
		return fmt.Errorf("victoriametrics: %w", err)
	}
	return nil
}

// Validate validates BuildkitConfig
func (c *BuildkitConfig) Validate() error {

	// Check for port conflicts in BuildkitConfig

	return nil
}

// Validate validates ContainerdConfig
func (c *ContainerdConfig) Validate() error {

	// Check for port conflicts in ContainerdConfig

	return nil
}

// Validate validates EtcdConfig
func (c *EtcdConfig) Validate() error {

	// Validate client_port
	if c.ClientPort != nil && (*c.ClientPort < 1 || *c.ClientPort > 65535) {
		return fmt.Errorf("client_port must be between 1 and 65535, got %d", *c.ClientPort)
	}

	// Validate http_client_port
	if c.HTTPClientPort != nil && (*c.HTTPClientPort < 1 || *c.HTTPClientPort > 65535) {
		return fmt.Errorf("http_client_port must be between 1 and 65535, got %d", *c.HTTPClientPort)
	}

	// Validate peer_port
	if c.PeerPort != nil && (*c.PeerPort < 1 || *c.PeerPort > 65535) {
		return fmt.Errorf("peer_port must be between 1 and 65535, got %d", *c.PeerPort)
	}

	// Check for port conflicts in EtcdConfig
	seen := make(map[int]bool)
	if c.ClientPort != nil {
		if seen[*c.ClientPort] {
			return fmt.Errorf("port conflict: port %d is used multiple times", *c.ClientPort)
		}
		seen[*c.ClientPort] = true
	}
	if c.HTTPClientPort != nil {
		if seen[*c.HTTPClientPort] {
			return fmt.Errorf("port conflict: port %d is used multiple times", *c.HTTPClientPort)
		}
		seen[*c.HTTPClientPort] = true
	}
	if c.PeerPort != nil {
		if seen[*c.PeerPort] {
			return fmt.Errorf("port conflict: port %d is used multiple times", *c.PeerPort)
		}
		seen[*c.PeerPort] = true
	}

	// Validate etcd endpoints requirement
	if c.StartEmbedded != nil && !*c.StartEmbedded && len(c.Endpoints) == 0 {
		return fmt.Errorf("etcd endpoints must be set when start_embedded=false")
	}

	return nil
}

// Validate validates ServerConfig
func (c *ServerConfig) Validate() error {

	// Validate address
	if c.Address != nil && *c.Address != "" {
		if _, _, err := net.SplitHostPort(*c.Address); err != nil {
			return fmt.Errorf("invalid address %q: %w", *c.Address, err)
		}
	}

	// Validate http_request_timeout minimum
	if c.HTTPRequestTimeout != nil && *c.HTTPRequestTimeout < 1 {
		return fmt.Errorf("http_request_timeout must be at least 1, got %d", *c.HTTPRequestTimeout)
	}

	// Validate runner_address
	if c.RunnerAddress != nil && *c.RunnerAddress != "" {
		if _, _, err := net.SplitHostPort(*c.RunnerAddress); err != nil {
			return fmt.Errorf("invalid runner_address %q: %w", *c.RunnerAddress, err)
		}
	}

	// Check for port conflicts in ServerConfig

	return nil
}

// Validate validates TLSConfig
func (c *TLSConfig) Validate() error {

	// Validate additional_ips
	for _, ip := range c.AdditionalIPs {
		if net.ParseIP(ip) == nil {
			return fmt.Errorf("invalid IP address %q in additional_ips", ip)
		}
	}

	// Check for port conflicts in TLSConfig

	return nil
}

// Validate validates VictoriaLogsConfig
func (c *VictoriaLogsConfig) Validate() error {

	// Validate address
	if c.Address != nil && *c.Address != "" {
		if _, _, err := net.SplitHostPort(*c.Address); err != nil {
			return fmt.Errorf("invalid address %q: %w", *c.Address, err)
		}
	}

	// Validate http_port
	if c.HTTPPort != nil && (*c.HTTPPort < 1 || *c.HTTPPort > 65535) {
		return fmt.Errorf("http_port must be between 1 and 65535, got %d", *c.HTTPPort)
	}

	// Validate retention_period regex
	if c.RetentionPeriod != nil && *c.RetentionPeriod != "" {
		matched, err := regexp.MatchString(`^\d+(ms|s|m|h|d|w|y)$`, *c.RetentionPeriod)
		if err != nil {
			return fmt.Errorf("invalid regex pattern for retention_period: %w", err)
		}
		if !matched {
			return fmt.Errorf("invalid retention_period %q: must match pattern %q", *c.RetentionPeriod, `^\d+(ms|s|m|h|d|w|y)$`)
		}
	}

	// Check for port conflicts in VictoriaLogsConfig

	return nil
}

// Validate validates VictoriaMetricsConfig
func (c *VictoriaMetricsConfig) Validate() error {

	// Validate address
	if c.Address != nil && *c.Address != "" {
		if _, _, err := net.SplitHostPort(*c.Address); err != nil {
			return fmt.Errorf("invalid address %q: %w", *c.Address, err)
		}
	}

	// Validate http_port
	if c.HTTPPort != nil && (*c.HTTPPort < 1 || *c.HTTPPort > 65535) {
		return fmt.Errorf("http_port must be between 1 and 65535, got %d", *c.HTTPPort)
	}

	// Validate retention_period regex
	if c.RetentionPeriod != nil && *c.RetentionPeriod != "" {
		matched, err := regexp.MatchString(`^\d+$`, *c.RetentionPeriod)
		if err != nil {
			return fmt.Errorf("invalid regex pattern for retention_period: %w", err)
		}
		if !matched {
			return fmt.Errorf("invalid retention_period %q: must match pattern %q", *c.RetentionPeriod, `^\d+$`)
		}
	}

	// Check for port conflicts in VictoriaMetricsConfig

	return nil
}
