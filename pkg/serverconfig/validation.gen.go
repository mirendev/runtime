// Code generated by configgen. DO NOT EDIT.

package serverconfig

import (
	"fmt"
	"net"
)

// Validate validates the configuration
func (c *Config) Validate() error {

	if err := c.Clickhouse.Validate(); err != nil {
		return fmt.Errorf("clickhouse: %w", err)
	}

	if err := c.Containerd.Validate(); err != nil {
		return fmt.Errorf("containerd: %w", err)
	}

	if err := c.Etcd.Validate(); err != nil {
		return fmt.Errorf("etcd: %w", err)
	}
	// Validate mode
	validModes := map[string]bool{
		"standalone":  true,
		"distributed": true,
	}
	if !validModes[c.Mode] {
		return fmt.Errorf("invalid mode %q: must be one of [standalone distributed]", c.Mode)
	}

	if err := c.Server.Validate(); err != nil {
		return fmt.Errorf("server: %w", err)
	}

	if err := c.Tls.Validate(); err != nil {
		return fmt.Errorf("tls: %w", err)
	}
	return nil
}

// Validate validates ClickHouseConfig
func (c *ClickHouseConfig) Validate() error {

	// Validate http_port
	if c.HttpPort < 1 || c.HttpPort > 65535 {
		return fmt.Errorf("http_port must be between 1 and 65535, got %d", c.HttpPort)
	}

	// Validate interserver_port
	if c.InterserverPort < 1 || c.InterserverPort > 65535 {
		return fmt.Errorf("interserver_port must be between 1 and 65535, got %d", c.InterserverPort)
	}

	// Validate native_port
	if c.NativePort < 1 || c.NativePort > 65535 {
		return fmt.Errorf("native_port must be between 1 and 65535, got %d", c.NativePort)
	}

	// Check for port conflicts in ClickHouseConfig
	ports := []int{
		c.HttpPort,
		c.InterserverPort,
		c.NativePort,
	}
	seen := make(map[int]bool)
	for _, port := range ports {
		if seen[port] {
			return fmt.Errorf("port conflict: port %d is used multiple times", port)
		}
		seen[port] = true
	}

	return nil
}

// Validate validates ContainerdConfig
func (c *ContainerdConfig) Validate() error {

	// Check for port conflicts in ContainerdConfig

	return nil
}

// Validate validates EtcdConfig
func (c *EtcdConfig) Validate() error {

	// Validate client_port
	if c.ClientPort < 1 || c.ClientPort > 65535 {
		return fmt.Errorf("client_port must be between 1 and 65535, got %d", c.ClientPort)
	}

	// Validate http_client_port
	if c.HttpClientPort < 1 || c.HttpClientPort > 65535 {
		return fmt.Errorf("http_client_port must be between 1 and 65535, got %d", c.HttpClientPort)
	}

	// Validate peer_port
	if c.PeerPort < 1 || c.PeerPort > 65535 {
		return fmt.Errorf("peer_port must be between 1 and 65535, got %d", c.PeerPort)
	}

	// Check for port conflicts in EtcdConfig
	ports := []int{
		c.ClientPort,
		c.HttpClientPort,
		c.PeerPort,
	}
	seen := make(map[int]bool)
	for _, port := range ports {
		if seen[port] {
			return fmt.Errorf("port conflict: port %d is used multiple times", port)
		}
		seen[port] = true
	}

	// Validate etcd endpoints requirement
	if !c.StartEmbedded && len(c.Endpoints) == 0 {
		return fmt.Errorf("etcd endpoints must be set when start_embedded=false")
	}

	return nil
}

// Validate validates ServerConfig
func (c *ServerConfig) Validate() error {

	// Validate address
	if c.Address != "" {
		if _, _, err := net.SplitHostPort(c.Address); err != nil {
			return fmt.Errorf("invalid address %q: %w", c.Address, err)
		}
	}

	// Validate http_request_timeout minimum
	if c.HttpRequestTimeout < 1 {
		return fmt.Errorf("http_request_timeout must be at least 1, got %d", c.HttpRequestTimeout)
	}

	// Validate runner_address
	if c.RunnerAddress != "" {
		if _, _, err := net.SplitHostPort(c.RunnerAddress); err != nil {
			return fmt.Errorf("invalid runner_address %q: %w", c.RunnerAddress, err)
		}
	}

	// Check for port conflicts in ServerConfig

	return nil
}

// Validate validates TLSConfig
func (c *TLSConfig) Validate() error {

	// Validate additional_ips
	for _, ip := range c.AdditionalIps {
		if net.ParseIP(ip) == nil {
			return fmt.Errorf("invalid IP address %q in additional_ips", ip)
		}
	}

	// Check for port conflicts in TLSConfig

	return nil
}
