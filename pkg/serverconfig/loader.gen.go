// Code generated by configgen. DO NOT EDIT.

package serverconfig

import (
	"fmt"
	"log/slog"
	"os"
	"path/filepath"

	"github.com/pelletier/go-toml/v2"
)

// Load loads configuration from all sources with proper precedence:
// CLI flags > Environment variables > Mode defaults > Config file > Defaults
func Load(configPath string, flags *CLIFlags, log *slog.Logger) (*Config, error) {
	if log == nil {
		log = slog.Default()
	}

	cfg := DefaultConfig()

	// Determine data path for config discovery with proper precedence
	// CLI > Env > Defaults
	dataPathForSearch := cfg.Server.DataPath
	if flags != nil && flags.ServerConfigDataPath != nil && *flags.ServerConfigDataPath != "" {
		dataPathForSearch = *flags.ServerConfigDataPath
	} else if envDataPath := os.Getenv("MIREN_SERVER_DATA_PATH"); envDataPath != "" {
		dataPathForSearch = envDataPath
	}

	// Load config file
	filePath := findConfigFile(configPath, dataPathForSearch)
	if filePath != "" {
		log.Info("loading config file", "path", filePath)
		if err := loadConfigFile(filePath, cfg); err != nil {
			return nil, fmt.Errorf("failed to load config file: %w", err)
		}
	} else if configPath != "" {
		return nil, fmt.Errorf("config file not found: %s", configPath)
	}

	// Apply mode defaults (after config file, before env/CLI)
	// These act as defaults that can be overridden
	cfg.ApplyModeDefaults()

	// Apply environment variables
	if err := applyEnvironmentVariables(cfg, log); err != nil {
		return nil, fmt.Errorf("failed to apply environment variables: %w", err)
	}

	// Apply CLI flags
	if flags != nil {
		applyCLIFlags(cfg, flags)
	}

	// Validate
	if err := cfg.Validate(); err != nil {
		return nil, fmt.Errorf("configuration validation failed: %w", err)
	}

	return cfg, nil
}

func findConfigFile(explicitPath, dataPath string) string {
	if explicitPath != "" {
		if _, err := os.Stat(explicitPath); err == nil {
			return explicitPath
		}
		return ""
	}

	searchPaths := []string{
		"/etc/miren/server.toml",
		filepath.Join(dataPath, "config", "server.toml"),
	}

	for _, path := range searchPaths {
		if _, err := os.Stat(path); err == nil {
			return path
		}
	}

	return ""
}

func loadConfigFile(path string, cfg *Config) error {
	data, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read config file: %w", err)
	}

	if err := toml.Unmarshal(data, cfg); err != nil {
		return fmt.Errorf("failed to parse TOML: %w", err)
	}

	return nil
}

func applyCLIFlags(cfg *Config, flags *CLIFlags) {

	if flags.ClickHouseConfigAddress != nil && *flags.ClickHouseConfigAddress != "" {
		cfg.Clickhouse.Address = *flags.ClickHouseConfigAddress
	}

	if flags.ClickHouseConfigHttpPort != nil {
		cfg.Clickhouse.HttpPort = *flags.ClickHouseConfigHttpPort
	}

	if flags.ClickHouseConfigInterserverPort != nil {
		cfg.Clickhouse.InterserverPort = *flags.ClickHouseConfigInterserverPort
	}

	if flags.ClickHouseConfigNativePort != nil {
		cfg.Clickhouse.NativePort = *flags.ClickHouseConfigNativePort
	}

	if flags.ClickHouseConfigStartEmbedded != nil {
		cfg.Clickhouse.StartEmbedded = *flags.ClickHouseConfigStartEmbedded
	}

	if flags.Mode != nil && *flags.Mode != "" {
		cfg.Mode = *flags.Mode
	}

	if flags.ContainerdConfigBinaryPath != nil && *flags.ContainerdConfigBinaryPath != "" {
		cfg.Containerd.BinaryPath = *flags.ContainerdConfigBinaryPath
	}

	if flags.ContainerdConfigSocketPath != nil && *flags.ContainerdConfigSocketPath != "" {
		cfg.Containerd.SocketPath = *flags.ContainerdConfigSocketPath
	}

	if flags.ContainerdConfigStartEmbedded != nil {
		cfg.Containerd.StartEmbedded = *flags.ContainerdConfigStartEmbedded
	}

	if flags.EtcdConfigClientPort != nil {
		cfg.Etcd.ClientPort = *flags.EtcdConfigClientPort
	}

	if len(flags.EtcdConfigEndpoints) > 0 {
		cfg.Etcd.Endpoints = flags.EtcdConfigEndpoints
	}

	if flags.EtcdConfigHttpClientPort != nil {
		cfg.Etcd.HttpClientPort = *flags.EtcdConfigHttpClientPort
	}

	if flags.EtcdConfigPeerPort != nil {
		cfg.Etcd.PeerPort = *flags.EtcdConfigPeerPort
	}

	if flags.EtcdConfigPrefix != nil && *flags.EtcdConfigPrefix != "" {
		cfg.Etcd.Prefix = *flags.EtcdConfigPrefix
	}

	if flags.EtcdConfigStartEmbedded != nil {
		cfg.Etcd.StartEmbedded = *flags.EtcdConfigStartEmbedded
	}

	if flags.ServerConfigAddress != nil && *flags.ServerConfigAddress != "" {
		cfg.Server.Address = *flags.ServerConfigAddress
	}

	if flags.ServerConfigConfigClusterName != nil && *flags.ServerConfigConfigClusterName != "" {
		cfg.Server.ConfigClusterName = *flags.ServerConfigConfigClusterName
	}

	if flags.ServerConfigDataPath != nil && *flags.ServerConfigDataPath != "" {
		cfg.Server.DataPath = *flags.ServerConfigDataPath
	}

	if flags.ServerConfigHttpRequestTimeout != nil {
		cfg.Server.HttpRequestTimeout = *flags.ServerConfigHttpRequestTimeout
	}

	if flags.ServerConfigReleasePath != nil && *flags.ServerConfigReleasePath != "" {
		cfg.Server.ReleasePath = *flags.ServerConfigReleasePath
	}

	if flags.ServerConfigRunnerAddress != nil && *flags.ServerConfigRunnerAddress != "" {
		cfg.Server.RunnerAddress = *flags.ServerConfigRunnerAddress
	}

	if flags.ServerConfigRunnerId != nil && *flags.ServerConfigRunnerId != "" {
		cfg.Server.RunnerId = *flags.ServerConfigRunnerId
	}

	if flags.ServerConfigSkipClientConfig != nil {
		cfg.Server.SkipClientConfig = *flags.ServerConfigSkipClientConfig
	}

	if len(flags.TLSConfigAdditionalIps) > 0 {
		cfg.Tls.AdditionalIps = flags.TLSConfigAdditionalIps
	}

	if len(flags.TLSConfigAdditionalNames) > 0 {
		cfg.Tls.AdditionalNames = flags.TLSConfigAdditionalNames
	}

	if flags.TLSConfigStandardTls != nil {
		cfg.Tls.StandardTls = *flags.TLSConfigStandardTls
	}

}

// ApplyModeDefaults applies mode-specific defaults
func (c *Config) ApplyModeDefaults() {
	if c.Mode == "standalone" {
		c.Etcd.StartEmbedded = true
		c.Clickhouse.StartEmbedded = true
		c.Containerd.StartEmbedded = true
	}
}
