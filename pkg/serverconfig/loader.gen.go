// Code generated by configgen. DO NOT EDIT.

package serverconfig

import (
	"fmt"
	"log/slog"
	"os"
	"path/filepath"

	"github.com/pelletier/go-toml/v2"
)

// Load loads configuration from all sources with proper precedence:
// CLI flags > Environment variables > Config file > Defaults
func Load(configPath string, flags *CLIFlags, log *slog.Logger) (*Config, error) {
	if log == nil {
		log = slog.Default()
	}

	cfg := DefaultConfig()

	// Determine data path for config discovery with proper precedence
	// CLI > Env > Defaults
	var dataPathForSearch string
	if cfg.Server.DataPath != nil {
		dataPathForSearch = *cfg.Server.DataPath
	}
	if flags != nil && flags.ServerConfigDataPath != nil && *flags.ServerConfigDataPath != "" {
		dataPathForSearch = *flags.ServerConfigDataPath
	} else if envDataPath := os.Getenv("MIREN_SERVER_DATA_PATH"); envDataPath != "" {
		dataPathForSearch = envDataPath
	}

	// Load config file
	filePath := findConfigFile(configPath, dataPathForSearch)
	if filePath != "" {
		log.Info("loading config file", "path", filePath)
		if err := loadConfigFile(filePath, cfg); err != nil {
			return nil, fmt.Errorf("failed to load config file: %w", err)
		}
	} else if configPath != "" {
		return nil, fmt.Errorf("config file not found: %s", configPath)
	}

	// Resolve the effective mode first (CLI > Env > Config > Default)
	// We need this to apply mode-specific defaults correctly
	var effectiveMode string
	if cfg.Mode != nil {
		effectiveMode = *cfg.Mode
	}
	if envMode := os.Getenv("MIREN_MODE"); envMode != "" {
		effectiveMode = envMode
	}
	if flags != nil && flags.Mode != nil && *flags.Mode != "" {
		effectiveMode = *flags.Mode
	}

	// Apply mode defaults based on the resolved mode
	// Only set if not already set (nil check)
	if effectiveMode == "standalone" {
		if cfg.Etcd.StartEmbedded == nil {
			cfg.Etcd.StartEmbedded = boolPtr(true)
		}
		if cfg.Containerd.StartEmbedded == nil {
			cfg.Containerd.StartEmbedded = boolPtr(true)
		}
		if cfg.Victorialogs.StartEmbedded == nil {
			cfg.Victorialogs.StartEmbedded = boolPtr(true)
		}
		if cfg.Victoriametrics.StartEmbedded == nil {
			cfg.Victoriametrics.StartEmbedded = boolPtr(true)
		}
	}

	// Apply environment variables (can override mode defaults)
	if err := applyEnvironmentVariables(cfg, log); err != nil {
		return nil, fmt.Errorf("failed to apply environment variables: %w", err)
	}

	// Apply CLI flags (can override everything)
	if flags != nil {
		applyCLIFlags(cfg, flags)
	}

	// Post-process etcd configuration
	// If embedded etcd is enabled and no endpoints are specified, set default endpoint
	if cfg.Etcd.StartEmbedded != nil && *cfg.Etcd.StartEmbedded && len(cfg.Etcd.Endpoints) == 0 {
		port := 12379
		if cfg.Etcd.ClientPort != nil {
			port = *cfg.Etcd.ClientPort
		}
		cfg.Etcd.Endpoints = []string{fmt.Sprintf("http://127.0.0.1:%d", port)}
	}

	// Validate
	if err := cfg.Validate(); err != nil {
		return nil, fmt.Errorf("configuration validation failed: %w", err)
	}

	return cfg, nil
}

func findConfigFile(explicitPath, dataPath string) string {
	if explicitPath != "" {
		if _, err := os.Stat(explicitPath); err == nil {
			return explicitPath
		}
		return ""
	}

	searchPaths := []string{
		"/etc/miren/server.toml",
		filepath.Join(dataPath, "config", "server.toml"),
	}

	for _, path := range searchPaths {
		if _, err := os.Stat(path); err == nil {
			return path
		}
	}

	return ""
}

func loadConfigFile(path string, cfg *Config) error {
	data, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("failed to read config file: %w", err)
	}

	if err := toml.Unmarshal(data, cfg); err != nil {
		return fmt.Errorf("failed to parse TOML: %w", err)
	}

	return nil
}

func applyCLIFlags(cfg *Config, flags *CLIFlags) {

	if flags.Mode != nil && *flags.Mode != "" {
		cfg.Mode = flags.Mode
	}

	if flags.ContainerdConfigBinaryPath != nil && *flags.ContainerdConfigBinaryPath != "" {
		cfg.Containerd.BinaryPath = flags.ContainerdConfigBinaryPath
	}

	if flags.ContainerdConfigSocketPath != nil && *flags.ContainerdConfigSocketPath != "" {
		cfg.Containerd.SocketPath = flags.ContainerdConfigSocketPath
	}

	if flags.ContainerdConfigStartEmbedded != nil {
		cfg.Containerd.StartEmbedded = flags.ContainerdConfigStartEmbedded
	}

	if flags.EtcdConfigClientPort != nil {
		cfg.Etcd.ClientPort = flags.EtcdConfigClientPort
	}

	if len(flags.EtcdConfigEndpoints) > 0 {
		cfg.Etcd.Endpoints = flags.EtcdConfigEndpoints
	}

	if flags.EtcdConfigHTTPClientPort != nil {
		cfg.Etcd.HTTPClientPort = flags.EtcdConfigHTTPClientPort
	}

	if flags.EtcdConfigPeerPort != nil {
		cfg.Etcd.PeerPort = flags.EtcdConfigPeerPort
	}

	if flags.EtcdConfigPrefix != nil && *flags.EtcdConfigPrefix != "" {
		cfg.Etcd.Prefix = flags.EtcdConfigPrefix
	}

	if flags.EtcdConfigStartEmbedded != nil {
		cfg.Etcd.StartEmbedded = flags.EtcdConfigStartEmbedded
	}

	if flags.ServerConfigAddress != nil && *flags.ServerConfigAddress != "" {
		cfg.Server.Address = flags.ServerConfigAddress
	}

	if flags.ServerConfigConfigClusterName != nil && *flags.ServerConfigConfigClusterName != "" {
		cfg.Server.ConfigClusterName = flags.ServerConfigConfigClusterName
	}

	if flags.ServerConfigDataPath != nil && *flags.ServerConfigDataPath != "" {
		cfg.Server.DataPath = flags.ServerConfigDataPath
	}

	if flags.ServerConfigHTTPRequestTimeout != nil {
		cfg.Server.HTTPRequestTimeout = flags.ServerConfigHTTPRequestTimeout
	}

	if flags.ServerConfigReleasePath != nil && *flags.ServerConfigReleasePath != "" {
		cfg.Server.ReleasePath = flags.ServerConfigReleasePath
	}

	if flags.ServerConfigRunnerAddress != nil && *flags.ServerConfigRunnerAddress != "" {
		cfg.Server.RunnerAddress = flags.ServerConfigRunnerAddress
	}

	if flags.ServerConfigRunnerID != nil && *flags.ServerConfigRunnerID != "" {
		cfg.Server.RunnerID = flags.ServerConfigRunnerID
	}

	if flags.ServerConfigSkipClientConfig != nil {
		cfg.Server.SkipClientConfig = flags.ServerConfigSkipClientConfig
	}

	if len(flags.TLSConfigAdditionalIPs) > 0 {
		cfg.TLS.AdditionalIPs = flags.TLSConfigAdditionalIPs
	}

	if len(flags.TLSConfigAdditionalNames) > 0 {
		cfg.TLS.AdditionalNames = flags.TLSConfigAdditionalNames
	}

	if flags.TLSConfigStandardTLS != nil {
		cfg.TLS.StandardTLS = flags.TLSConfigStandardTLS
	}

	if flags.VictoriaLogsConfigAddress != nil && *flags.VictoriaLogsConfigAddress != "" {
		cfg.Victorialogs.Address = flags.VictoriaLogsConfigAddress
	}

	if flags.VictoriaLogsConfigHTTPPort != nil {
		cfg.Victorialogs.HTTPPort = flags.VictoriaLogsConfigHTTPPort
	}

	if flags.VictoriaLogsConfigRetentionPeriod != nil && *flags.VictoriaLogsConfigRetentionPeriod != "" {
		cfg.Victorialogs.RetentionPeriod = flags.VictoriaLogsConfigRetentionPeriod
	}

	if flags.VictoriaLogsConfigStartEmbedded != nil {
		cfg.Victorialogs.StartEmbedded = flags.VictoriaLogsConfigStartEmbedded
	}

	if flags.VictoriaMetricsConfigAddress != nil && *flags.VictoriaMetricsConfigAddress != "" {
		cfg.Victoriametrics.Address = flags.VictoriaMetricsConfigAddress
	}

	if flags.VictoriaMetricsConfigHTTPPort != nil {
		cfg.Victoriametrics.HTTPPort = flags.VictoriaMetricsConfigHTTPPort
	}

	if flags.VictoriaMetricsConfigRetentionPeriod != nil && *flags.VictoriaMetricsConfigRetentionPeriod != "" {
		cfg.Victoriametrics.RetentionPeriod = flags.VictoriaMetricsConfigRetentionPeriod
	}

	if flags.VictoriaMetricsConfigStartEmbedded != nil {
		cfg.Victoriametrics.StartEmbedded = flags.VictoriaMetricsConfigStartEmbedded
	}

}
