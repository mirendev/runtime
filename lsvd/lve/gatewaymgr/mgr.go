package gatewaymgr

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/fs"
	"log/slog"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"text/template"

	validation "github.com/go-ozzo/ozzo-validation/v4"
	"github.com/go-ozzo/ozzo-validation/v4/is"
	"github.com/lab47/lsvd/logger"
	"github.com/pkg/errors"
	"miren.dev/runtime/lsvd/lve/paths"
	"miren.dev/runtime/lsvd/lve/pkg/sval"
)

func Create(log *slog.Logger, rootDir string, cfg *Config) error {
	root := paths.Root(rootDir)
	path := root.Instance(cfg.Id)

	gen := []struct {
		name       string
		executable bool
		fn         func(log *slog.Logger, cfg *Config) ([]byte, error)
	}{
		{"dnsmasq.conf", false, GenerateDnsMasq},
		{"interfaces", false, GenerateInterfaces},
		{"boot", true, GenerateBoot},
	}

	cfgPath := filepath.Join(path, "config")

	err := os.MkdirAll(cfgPath, 0755)
	if err != nil {
		return err
	}

	for _, g := range gen {
		fileData, err := g.fn(log, cfg)
		if err != nil {
			return err
		}

		var perm fs.FileMode = 0644

		if g.executable {
			perm = 0755
		}

		log.Debug("writing config file", "name", g.name)

		err = os.WriteFile(filepath.Join(cfgPath, g.name), fileData, perm)
		if err != nil {
			return err
		}
	}

	err = SetupHostInterfaces(log, cfg)
	if err != nil {
		return err
	}

	for _, inf := range cfg.Interfaces {
		err := root.SetupVPC(inf.VPC)
		if err != nil {
			return err
		}

		log.Info("configured vpc on disk", "id", inf.VPC)
	}

	return nil
}

func Run() {
	log := logger.New(logger.Info)

	var cfg Config

	f, err := os.Open("/labcfg/gateway.json")
	if err != nil {
		log.Error("error loading gateway config", "error", err)
		os.Exit(1)
	}

	err = json.NewDecoder(f).Decode(&cfg)
	if err != nil {
		log.Error("error parsing gateway config", "error", err)
		os.Exit(1)
	}

	f.Close()
}

func GenerateDnsMasq(log *slog.Logger, cfg *Config) ([]byte, error) {
	t, err := template.New("masq").Parse(`
# generated by gatewaymgr
no-hosts
local-ttl=60
interface=int0
dhcp-range={{.DHCP.Start}},{{.DHCP.End}},{{.DHCP.Netmask}},infinite
dhcp-option=option:router,{{.DHCP.Router}}
dhcp-range=::,ra-only
dhcp-rapid-commit
enable-ra
`)

	if err != nil {
		return nil, errors.Wrapf(err, "formatting dnsmasq config")
	}

	var buf bytes.Buffer

	err = t.ExecuteTemplate(&buf, "masq", cfg)
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

type SubStruct[T any] struct {
	fn func(v T) error
}

func (s SubStruct[T]) Validate(value any) error {
	return s.fn(value.(T))
}

func Sub[T any](fn func(v T) error) SubStruct[T] {
	return SubStruct[T]{fn: fn}
}

func GenerateInterfaces(log *slog.Logger, cfg *Config) ([]byte, error) {
	err := validation.ValidateStruct(cfg.DHCP,
		validation.Field(&cfg.DHCP.Start, is.IP),
		validation.Field(&cfg.DHCP.End, is.IP),
		validation.Field(&cfg.DHCP.Netmask, is.IP),
		validation.Field(&cfg.DHCP.Router, is.IP),
	)
	if err != nil {
		return nil, err
	}

	err = validation.ValidateStruct(cfg.Router,
		validation.Field(&cfg.Router.Address, is.IP),
		validation.Field(&cfg.Router.Netmask, is.IP),
	)
	if err != nil {
		return nil, err
	}

	for _, i := range cfg.Interfaces {
		log.Info("configuring interface", "name", i.Name, "mac", i.Id.MacString())
	}

	t, err := template.New("interfaces").Parse(`
auto int0
auto x0

iface int0
  use link
	use forward

	address {{.DHCP.Router}}
	netmask {{.DHCP.Netmask}}
	gateway {{.Router.Gateway}}
	
	forward-ipv4 yes
	forward-ipv6 yes

iface x0
	use link
	use forward
	
	address {{.Router.Address}}

	forward-ipv4 yes
	forward-ipv6 yes
`)

	if err != nil {
		return nil, errors.Wrapf(err, "formatting dnsmasq config")
	}

	var buf bytes.Buffer

	err = t.ExecuteTemplate(&buf, "interfaces", cfg)
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func GenerateBoot(log *slog.Logger, cfg *Config) ([]byte, error) {
	err := validation.ValidateStruct(cfg,
		validation.Field(&cfg.Interfaces, validation.Length(2, -1)),
		validation.Field(&cfg.Interfaces, sval.Each(func(c InterfaceConfig) error {
			return validation.ValidateStruct(&c,
				validation.Field(&c.VPC, validation.Required),
				validation.Field(&c.Name, validation.Required),
				validation.Field(&c.Id, validation.Required),
			)
		})),
	)
	if err != nil {
		return nil, err
	}

	t, err := template.New("boot").Parse(`
#!/bin/sh

{{ range $int := .Interfaces }}
nameif -s {{with $int}}{{.Name}} {{.Id.MacString}}{{end}}
{{ end }}

cp interfaces /etc/network/interfaces
cp dnsmasq.conf /etc/dnsmasq.d/root.conf

echo "nameserver 8.8.8.8" > /etc/resolv.conf

iptables -t nat -A POSTROUTING -o x0 -j MASQUERADE

dnsmasq -C /etc/dnsmasq.conf
`)

	if err != nil {
		return nil, errors.Wrapf(err, "formatting dnsmasq config")
	}

	var buf bytes.Buffer

	err = t.ExecuteTemplate(&buf, "boot", cfg)
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func SetupHostInterfaces(log *slog.Logger, cfg *Config) error {
	for _, i := range cfg.Interfaces {
		if i.HostTap == "" {
			continue
		}

		log.Info("configuring host tap", "host-name", i.HostTap, "address", i.Id.MacString())

		_, err := net.InterfaceByName(i.HostTap)
		if err != nil {
			out, err := exec.Command("ip", "link",
				"add", "link", "enp2s0",
				"name", i.HostTap,
				"address", i.Id.MacString(),
				"type", "macvtap",
				"mode", "bridge").CombinedOutput()
			if err != nil {
				fmt.Println("ip(2) error output:", string(out))
				return err
			}

			out, err = exec.Command("ip", "link", "set", i.HostTap, "up").CombinedOutput()
			if err != nil {
				fmt.Println("ip(2) error output:", string(out))
				return err
			}

			inf, err := net.InterfaceByName(i.HostTap)
			if err != nil {
				return err
			}

			if inf.Flags&net.FlagUp == 0 {
				return fmt.Errorf("host interface could not be activated")
			}

			path := fmt.Sprintf("/dev/tap%d", inf.Index)
			err = os.Chmod(path, 0666)
			if err != nil {
				return err
			}
		}
	}

	return nil
}
