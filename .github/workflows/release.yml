name: Release

on:
  workflow_run:
    workflows: ["Test"]
    types: [completed]
    # Note: No branches filter - triggers for both main branch and tags
    # This ensures all releases (main builds and tagged releases) wait for tests to pass

concurrency:
  group: release-${{ github.event.workflow_run.head_branch || github.ref_name }}
  cancel-in-progress: true

jobs:
  check-test-success:
    runs-on: ubuntu-latest
    # Skip check for manual/push triggers (for testing), require success for workflow_run
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Check test workflow status
        run: echo "Tests passed successfully, proceeding with release"

  tests-failed:
    runs-on: ubuntu-latest
    # Only notify for actual failures on main branch or version tags, not for cancellations or PRs
    if: ${{ github.event.workflow_run.conclusion == 'failure' && (github.event.workflow_run.head_branch == 'main' || startsWith(github.event.workflow_run.head_branch, 'v')) }}
    steps:
      - name: Tests failed - blocking release
        run: |
          REF_NAME="${{ github.event.workflow_run.head_branch }}"
          echo "
          ╔═══════════════════════════════════════════════════════════════════════════╗
          ║                                                                           ║
          ║   ❌ ❌ ❌  TESTS FAILED - RELEASE BLOCKED  ❌ ❌ ❌                       ║
          ║                                                                           ║
          ║   The test workflow did not pass successfully.                           ║
          ║   Release artifacts will NOT be built or pushed.                         ║
          ║                                                                           ║
          ║   Ref: $REF_NAME                                                         ║
          ║   Test workflow conclusion: ${{ github.event.workflow_run.conclusion }}  ║
          ║   Test workflow run: ${{ github.event.workflow_run.html_url }}           ║
          ║                                                                           ║
          ╚═══════════════════════════════════════════════════════════════════════════╝
          "
          exit 1

      - name: Send Slack notification for test failure
        if: always()
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.SLACK_BOT_TOKEN }}
          payload: |
            {
              "channel": "${{ vars.SLACK_CHANNEL_ID }}",
              "text": "❌ Tests failed for ${{ github.event.workflow_run.head_branch }} - Release blocked",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "❌ *Tests failed for `${{ github.event.workflow_run.head_branch }}`*\nRelease artifacts will not be built or pushed."
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Commit:*\n${{ github.event.workflow_run.head_commit.message }}"
                  }
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Author:* ${{ github.event.workflow_run.head_commit.author.name }}"
                  }
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "<${{ github.event.workflow_run.repository.html_url }}/commit/${{ github.event.workflow_run.head_sha }}|View commit> • <${{ github.event.workflow_run.html_url }}|View test run>"
                    }
                  ]
                }
              ],
              "unfurl_links": false,
              "unfurl_media": false
            }
  package:
    needs: check-test-success
    # Only build releases for main branch or version tags (or any branch for manual/push triggers during testing)
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.head_branch == 'main' || startsWith(github.event.workflow_run.head_branch, 'v') }}
    strategy:
      matrix:
        include:
          - arch: amd64
            runner: depot-ubuntu-latest
          - arch: arm64
            runner: depot-ubuntu-latest-arm
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: write
    steps:
    - uses: actions/checkout@v5
      with:
        ref: ${{ github.event.workflow_run.head_branch || github.ref }}

    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version-file: 'go.mod'
        cache: true

    - name: Install iso
      run: |
        go install miren.dev/iso/cmd/iso@latest
        echo "$(go env GOPATH)/bin" >> "$GITHUB_PATH"

    - name: Build and package for ${{ matrix.arch }}
      env:
        GIT_BRANCH: ${{ github.event.workflow_run.head_branch || github.ref_name }}
        GIT_COMMIT: ${{ github.event.workflow_run.head_sha || github.sha }}
      run: |
        # Pass git info from GitHub Actions context to avoid git commands in iso
        export BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
        make release-data
        mv release.tar.gz release-base-linux-${{ matrix.arch }}.tar.gz
    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: miren-base-linux-${{ matrix.arch }}
        path: release-base-linux-${{ matrix.arch }}.tar.gz
        retention-days: 1

    - name: Send Slack notification on package failure
      if: failure()
      uses: slackapi/slack-github-action@v2.1.1
      with:
        method: chat.postMessage
        token: ${{ secrets.SLACK_BOT_TOKEN }}
        payload: |
          {
            "channel": "${{ vars.SLACK_CHANNEL_ID }}",
            "text": "❌ Miren release packaging failed for ${{ github.event.workflow_run.head_branch }}",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "❌ *Miren release packaging failed (${{ matrix.arch }})*\nFailed to build or package release artifacts."
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Branch:*\n`${{ github.event.workflow_run.head_branch }}`"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Architecture:*\n`${{ matrix.arch }}`"
                  }
                ]
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Commit:*\n${{ github.event.workflow_run.head_commit.message }}"
                }
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Author:* ${{ github.event.workflow_run.head_commit.author.name }}"
                }
              },
              {
                "type": "context",
                "elements": [
                  {
                    "type": "mrkdwn",
                    "text": "<${{ github.event.workflow_run.repository.html_url }}/commit/${{ github.event.workflow_run.head_sha }}|View commit> • <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View workflow run>"
                  }
                ]
              }
            ],
            "unfurl_links": false,
            "unfurl_media": false
          }

  build-binaries:
    needs: check-test-success
    strategy:
      matrix:
        include:
          - os: linux
            arch: amd64
            runner: depot-ubuntu-latest
          - os: linux
            arch: arm64
            runner: depot-ubuntu-latest-arm
          - os: darwin
            arch: amd64
            runner: macos-latest
          - os: darwin
            arch: arm64
            runner: macos-latest
    runs-on: ${{ matrix.runner }}
    permissions:
      id-token: write
      attestations: write
      contents: read
    steps:
    - uses: actions/checkout@v5
      with:
        ref: ${{ github.event.workflow_run.head_branch || github.ref }}
    - name: Set up Go
      uses: actions/setup-go@v6
      with:
        go-version-file: 'go.mod'
    - name: Build binary for ${{ matrix.os }}-${{ matrix.arch }}
      run: |
        GOOS=${{ matrix.os }} GOARCH=${{ matrix.arch }} make bin/miren

    - name: Import certificate and sign macOS binary
      if: matrix.os == 'darwin'
      env:
        APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
        APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
      run: |
        set -x  # Enable command tracing

        # Decode the certificate
        echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > certificate.p12

        # Create keychain
        KEYCHAIN_PWD="ci-keychain-password"
        security create-keychain -p "$KEYCHAIN_PWD" build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p "$KEYCHAIN_PWD" build.keychain

        # Import certificate
        security import certificate.p12 -k build.keychain -P "$APPLE_CERTIFICATE_PASSWORD" -T /usr/bin/codesign

        # Allow codesign to access the keychain without prompting
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PWD" build.keychain

        # Get the signing identity from the keychain
        IDENTITY=$(security find-identity -v -p codesigning build.keychain | grep "Developer ID Application" | head -1 | sed 's/.*"\(.*\)".*/\1/')
        echo "Using signing identity: $IDENTITY"

        if [ -z "$IDENTITY" ]; then
          echo "ERROR: No Developer ID Application identity found"
          security find-identity -v -p codesigning build.keychain
          exit 1
        fi

        # Sign the binary with hardened runtime
        codesign --force --options runtime \
          --sign "$IDENTITY" \
          --timestamp \
          bin/miren

        # Verify the signature
        codesign --verify --verbose=2 bin/miren

        # Clean up
        rm certificate.p12

    - name: Notarize macOS binary
      if: matrix.os == 'darwin'
      env:
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        # Create a zip for notarization
        zip -j miren-notarize.zip bin/miren

        # Submit for notarization
        xcrun notarytool submit miren-notarize.zip \
          --apple-id "$APPLE_ID" \
          --password "$APPLE_ID_PASSWORD" \
          --team-id "$APPLE_TEAM_ID" \
          --wait

        # Clean up notarization zip
        rm miren-notarize.zip

        # Note: Can't staple bare binaries (only .app/.pkg/.dmg)
        # The binary is still notarized - Gatekeeper checks online on first run

    - name: Package binary
      run: |
        # Create a zip file with the binary
        zip -j miren-${{ matrix.os }}-${{ matrix.arch }}.zip bin/miren
    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: miren-${{ matrix.os }}-${{ matrix.arch }}
        path: miren-${{ matrix.os }}-${{ matrix.arch }}.zip
        retention-days: 1

  build-and-push-docker:
    needs: [package, upload-to-miren]
    runs-on: depot-ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event.workflow_run.head_branch || github.ref }}

      - name: Download amd64 package
        uses: actions/download-artifact@v4
        with:
          name: miren-base-linux-amd64
          path: artifacts/amd64

      - name: Download arm64 package
        uses: actions/download-artifact@v4
        with:
          name: miren-base-linux-arm64
          path: artifacts/arm64

      - name: Extract pre-built binaries
        run: |
          mkdir -p docker/artifacts/amd64 docker/artifacts/arm64
          tar -xzf artifacts/amd64/release-base-linux-amd64.tar.gz -C docker/artifacts/amd64
          tar -xzf artifacts/arm64/release-base-linux-arm64.tar.gz -C docker/artifacts/arm64

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WIF_PROVIDER }}
          service_account: ${{ secrets.WIF_SERVICE_ACCOUNT }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker us-central1-docker.pkg.dev

      - name: Determine Docker tags
        id: docker-tags
        run: |
          HEAD_BRANCH="${{ github.event.workflow_run.head_branch || github.ref_name }}"
          TAGS="us-central1-docker.pkg.dev/miren-cloud/miren-oci/miren:$HEAD_BRANCH"

          # Add latest tag for stable releases only (exclude all prereleases)
          # Prereleases have a hyphen: v0.0.0-test.1, v0.1.0-rc.1, v1.0.0-beta.1, etc.
          if [[ "$HEAD_BRANCH" == v* ]] && [[ ! "$HEAD_BRANCH" =~ ^v[0-9]+\.[0-9]+\.[0-9]+- ]]; then
            TAGS="$TAGS
          us-central1-docker.pkg.dev/miren-cloud/miren-oci/miren:latest"
          fi

          echo "tags<<EOF" >> $GITHUB_OUTPUT
          echo "$TAGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Build and push miren Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile.miren
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.docker-tags.outputs.tags }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Send Slack notification on Docker build failure
        if: failure()
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.SLACK_BOT_TOKEN }}
          payload: |
            {
              "channel": "${{ vars.SLACK_CHANNEL_ID }}",
              "text": "❌ Miren Docker build/push failed for ${{ github.event.workflow_run.head_branch }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "❌ *Miren Docker build/push failed*\nFailed to build or push Docker image to Artifact Registry."
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n`${{ github.event.workflow_run.head_branch }}`"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Commit:*\n${{ github.event.workflow_run.head_commit.message }}"
                  }
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "<${{ github.event.workflow_run.repository.html_url }}/commit/${{ github.event.workflow_run.head_sha }}|View commit> • <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View workflow run>"
                    }
                  ]
                }
              ],
              "unfurl_links": false,
              "unfurl_media": false
            }

  upload-to-miren:
    needs: [package, build-binaries]
    runs-on: depot-ubuntu-latest
    concurrency:
      group: upload-to-miren-${{ github.event.workflow_run.head_branch || github.ref_name }}
      cancel-in-progress: false
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v5
        with:
          ref: ${{ github.event.workflow_run.head_branch || github.ref }}

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Get OIDC token
        uses: actions/github-script@v7
        id: get-oidc-token
        with:
          script: |
            const token = await core.getIDToken()
            core.setOutput('token', token)

      - name: Upload to Miren API
        run: |
          set -eo pipefail

          HEAD_BRANCH="${{ github.event.workflow_run.head_branch || github.ref_name }}"

          # Determine if this is a tag build
          IS_TAG_BUILD=false
          IS_PRERELEASE=false
          if [[ "$HEAD_BRANCH" == v* ]]; then
            IS_TAG_BUILD=true
            TAG_NAME="$HEAD_BRANCH"
            echo "Building for tag: $TAG_NAME"

            # Check if this is a prerelease (has hyphen: v0.0.0-test.1, v0.1.0-rc.1, etc.)
            # Prereleases should NOT update the latest channel
            if [[ "$TAG_NAME" =~ ^v[0-9]+\.[0-9]+\.[0-9]+- ]]; then
              IS_PRERELEASE=true
              echo "Detected prerelease - will NOT update latest channel"
            fi
          fi

          # Determine upload paths (used by both artifact uploads and version.json)
          paths=()
          if [ "$IS_TAG_BUILD" = true ]; then
            # Always upload to the tag path
            paths+=("$TAG_NAME")
            # Only upload to latest for stable releases (not prereleases)
            if [ "$IS_PRERELEASE" = false ]; then
              paths+=("latest")
            fi
          else
            # For branches, upload to branch path only
            paths+=("$HEAD_BRANCH")
          fi

          echo "Upload paths: ${paths[*]}"

          # Create a manifest to track uploaded artifacts and their checksums
          echo '[]' > artifact-manifest.json

          # Function to upload a file and its checksum, and track in manifest
          upload_artifact() {
            local file_path="$1"
            local artifact_name="$2"
            local platform="${3:-}"
            local arch="${4:-}"

            echo "Uploading ${artifact_name}..."

            # Generate SHA256 checksum in standard format for sha256sum -c compatibility
            local checksum=$(sha256sum "${file_path}" | cut -d' ' -f1)
            echo "${checksum}  ${artifact_name}" > "${artifact_name}.sha256"

            # Get file size
            local size=$(stat -c%s "${file_path}" 2>/dev/null || stat -f%z "${file_path}" 2>/dev/null || echo 0)

            # Upload to all paths (paths array is set in outer scope)
            for path in "${paths[@]}"; do
              echo "Uploading to path: $path"

              # Upload main file
              curl --fail-with-body --retry 3 -X PUT \
                -H "Authorization: Bearer ${{ steps.get-oidc-token.outputs.token }}" \
                -F "file=@${file_path}" \
                "https://api.miren.cloud/assets/release/miren/${path}/${artifact_name}"

              # Upload checksum file
              curl --fail-with-body --retry 3 -X PUT \
                -H "Authorization: Bearer ${{ steps.get-oidc-token.outputs.token }}" \
                -F "file=@${artifact_name}.sha256" \
                "https://api.miren.cloud/assets/release/miren/${path}/${artifact_name}.sha256"
            done

            # Build artifact info object
            local artifact_obj=$(jq -n \
              --arg name "${artifact_name}" \
              --arg sha256 "${checksum}" \
              --argjson size "${size}" \
              --arg platform "${platform}" \
              --arg arch "${arch}" \
              '{name: $name, sha256: $sha256, size: $size} |
               if $platform != "" then . + {platform: $platform} else . end |
               if $arch != "" then . + {arch: $arch} else . end')

            # Add to manifest array
            jq --argjson obj "$artifact_obj" '. += [$obj]' artifact-manifest.json > tmp.json && mv tmp.json artifact-manifest.json
          }

          # Upload release packages
          for arch in amd64 arm64; do
            upload_artifact \
              "artifacts/miren-base-linux-${arch}/release-base-linux-${arch}.tar.gz" \
              "miren-base-linux-${arch}.tar.gz" \
              "linux" \
              "${arch}"
          done

          # Upload binary artifacts
          for os in linux darwin; do
            for arch in amd64 arm64; do
              upload_artifact \
                "artifacts/miren-${os}-${arch}/miren-${os}-${arch}.zip" \
                "miren-${os}-${arch}.zip" \
                "${os}" \
                "${arch}"
            done
          done

          # Upload docker-compose configuration
          upload_artifact \
            "docker/docker-compose.yml" \
            "docker-compose.yml"

          # Generate version metadata with the artifact manifest
          echo "Generating version.json with artifact manifest..."

          # Get git information
          COMMIT=$(git rev-parse HEAD)
          COMMIT_SHORT=$(git rev-parse --short HEAD)
          BRANCH="${{ github.event.workflow_run.head_branch || github.ref_name }}"
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Determine version string
          # Note: Uses workflow_run head_branch pattern matching rather than
          # git describe (used in build scripts). Produces equivalent results for tagged releases.
          if [[ $BRANCH =~ ^v[0-9]+\.[0-9]+\.[0-9]+ ]]; then
            VERSION="$BRANCH"
          elif [[ $BRANCH =~ ^release/(.*) ]]; then
            VERSION="${BASH_REMATCH[1]}"
          else
            VERSION="$BRANCH:$COMMIT_SHORT"
          fi

          # Create version.json with the artifact manifest
          jq -n \
            --arg version "$VERSION" \
            --arg commit "$COMMIT" \
            --arg branch "$BRANCH" \
            --arg build_date "$BUILD_DATE" \
            --slurpfile artifacts artifact-manifest.json \
            '{
              version: $version,
              commit: $commit,
              branch: $branch,
              build_date: $build_date,
              artifacts: $artifacts[0]
            }' > version.json

          echo "Generated version.json:"
          cat version.json

          # Upload version metadata to all paths
          for path in "${paths[@]}"; do
            echo "Uploading version.json to $path..."
            curl --fail-with-body --retry 3 -X PUT \
              -H "Authorization: Bearer ${{ steps.get-oidc-token.outputs.token }}" \
              -F "file=@version.json" \
              "https://api.miren.cloud/assets/release/miren/${path}/version.json"
          done

      - name: Send Slack notification on upload failure
        if: failure()
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.SLACK_BOT_TOKEN }}
          payload: |
            {
              "channel": "${{ vars.SLACK_CHANNEL_ID }}",
              "text": "❌ Miren release upload failed for ${{ github.event.workflow_run.head_branch }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "❌ *Miren release upload failed*\nFailed to upload release artifacts to Miren API."
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Branch:*\n`${{ github.event.workflow_run.head_branch }}`"
                    }
                  ]
                },
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Commit:*\n${{ github.event.workflow_run.head_commit.message }}"
                  }
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "<${{ github.event.workflow_run.repository.html_url }}/commit/${{ github.event.workflow_run.head_sha }}|View commit> • <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View workflow run>"
                    }
                  ]
                }
              ],
              "unfurl_links": false,
              "unfurl_media": false
            }

      - name: Send Slack notification on upload success
        if: success()
        run: |
          # Determine what was uploaded
          HEAD_BRANCH="${{ github.event.workflow_run.head_branch || github.ref_name }}"
          RELEASE_TYPE="branch"

          if [[ "$HEAD_BRANCH" == v* ]]; then
            # Check if it's a prerelease (has hyphen)
            if [[ "$HEAD_BRANCH" =~ ^v[0-9]+\.[0-9]+\.[0-9]+- ]]; then
              RELEASE_TYPE="prerelease"
              CHANNELS="$HEAD_BRANCH"
            else
              RELEASE_TYPE="release"
              CHANNELS="$HEAD_BRANCH, latest"
            fi
          else
            CHANNELS="$HEAD_BRANCH"
          fi

          # Get version from version.json
          VERSION=$(jq -r '.version' version.json)
          COMMIT_SHORT=$(echo "${{ github.event.workflow_run.head_sha || github.sha }}" | cut -c1-7)

          # Build the Slack message
          curl -X POST -H 'Content-type: application/json' \
            -H "Authorization: Bearer ${{ secrets.SLACK_BOT_TOKEN }}" \
            --data @- https://slack.com/api/chat.postMessage <<EOF
          {
            "channel": "${{ vars.SLACK_CHANNEL_ID }}",
            "text": "✅ Miren $RELEASE_TYPE $VERSION deployed",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "✅ Miren $RELEASE_TYPE \`$VERSION\` deployed to $CHANNELS"
                }
              },
              {
                "type": "context",
                "elements": [
                  {
                    "type": "mrkdwn",
                    "text": "<${{ github.event.workflow_run.repository.html_url }}/commit/${{ github.event.workflow_run.head_sha }}|$COMMIT_SHORT> • <${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|workflow>"
                  }
                ]
              }
            ],
            "unfurl_links": false,
            "unfurl_media": false
          }
          EOF

  update-homebrew-tap:
    needs: [upload-to-miren]
    runs-on: ubuntu-latest
    # Only update homebrew tap for stable version tags (not prereleases, not branch builds)
    if: ${{ startsWith(github.event.workflow_run.head_branch, 'v') && !contains(github.event.workflow_run.head_branch, '-') }}
    steps:
      - name: Generate GitHub App token
        id: generate-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.HOMEBREW_TAP_APP_ID }}
          private-key: ${{ secrets.HOMEBREW_TAP_APP_KEY }}
          owner: mirendev
          repositories: homebrew-tap

      - name: Trigger homebrew-tap update
        env:
          GH_TOKEN: ${{ steps.generate-token.outputs.token }}
        run: |
          VERSION="${{ github.event.workflow_run.head_branch }}"
          echo "Triggering homebrew-tap update for $VERSION..."

          gh workflow run update-cask.yml \
            --repo mirendev/homebrew-tap \
            -f version="$VERSION"

          echo "Homebrew tap update triggered for $VERSION"

      - name: Send Slack notification on homebrew update failure
        if: failure()
        uses: slackapi/slack-github-action@v2.1.1
        with:
          method: chat.postMessage
          token: ${{ secrets.SLACK_BOT_TOKEN }}
          payload: |
            {
              "channel": "${{ vars.SLACK_CHANNEL_ID }}",
              "text": "⚠️ Homebrew tap update failed for ${{ github.event.workflow_run.head_branch }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "⚠️ *Homebrew tap update failed*\nRelease artifacts were uploaded successfully, but the homebrew tap update failed."
                  }
                },
                {
                  "type": "section",
                  "fields": [
                    {
                      "type": "mrkdwn",
                      "text": "*Version:*\n`${{ github.event.workflow_run.head_branch }}`"
                    }
                  ]
                },
                {
                  "type": "context",
                  "elements": [
                    {
                      "type": "mrkdwn",
                      "text": "You can manually update the tap by running: `gh workflow run update-cask.yml -R mirendev/homebrew-tap -f version=${{ github.event.workflow_run.head_branch }}`"
                    }
                  ]
                }
              ],
              "unfurl_links": false,
              "unfurl_media": false
            }

